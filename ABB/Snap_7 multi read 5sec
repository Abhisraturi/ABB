import os
import json
import asyncio
import aiohttp
import logging
import traceback
from datetime import datetime

BASE_FOLDER = r"E:\COBBLE DETECTION\PLC_JSON"
PAYLOAD_BASE_FOLDER = r"E:\COBBLE DETECTION\PLC_JSON_PAYLOAD"
API_URL = "http://104.154.22.115:8001/app/v0.0.1/plc/raw-post"
SCHEDULE_LOG_FILE = os.path.join(BASE_FOLDER, "schedule.log")
EXECUTION_LOG_FILE = os.path.join(BASE_FOLDER, "execution.log")
MAX_CONCURRENT_WORKERS = 20
SEND_INTERVAL = 0.03  # 30 ms

os.makedirs(PAYLOAD_BASE_FOLDER, exist_ok=True)

schedule_logger = logging.getLogger('schedule')
schedule_logger.setLevel(logging.INFO)
schedule_handler = logging.FileHandler(SCHEDULE_LOG_FILE)
schedule_handler.setFormatter(logging.Formatter('%(asctime)s | %(message)s', datefmt='%Y-%m-%d %H:%M:%S'))
schedule_logger.addHandler(schedule_handler)

execution_logger = logging.getLogger('execution')
execution_logger.setLevel(logging.INFO)
execution_handler = logging.FileHandler(EXECUTION_LOG_FILE)
execution_handler.setFormatter(logging.Formatter('%(asctime)s | %(message)s', datefmt='%Y-%m-%d %H:%M:%S'))
execution_logger.addHandler(execution_handler)

def get_latest_folder(base_folder):
    folders = [f for f in os.listdir(base_folder) if f.startswith("JSON_") and os.path.isdir(os.path.join(base_folder, f))]
    if not folders:
        return None
    folders.sort(key=lambda x: datetime.strptime(x[5:], "%Y%m%d_%H%M"))
    return os.path.join(base_folder, folders[-1])

def get_json_files(folder_path):
    return sorted([os.path.join(folder_path, f) for f in os.listdir(folder_path) if f.endswith(".json")])

def get_payload_folder():
    now = datetime.now()
    folder_name = now.strftime("Payload_%Y%m%d_%H%M")
    folder_path = os.path.join(PAYLOAD_BASE_FOLDER, folder_name)
    os.makedirs(folder_path, exist_ok=True)
    return folder_path

async def worker(name, session, queue):
    while True:
        file_path, scheduled_time = await queue.get()
        try:
       
            with open(file_path, 'r') as f:
                data = json.load(f)
            data['Timestamp'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")

            payload_folder = get_payload_folder()
            payload_path = os.path.join(payload_folder, os.path.basename(file_path))
            with open(payload_path, 'w') as f:
                json.dump(data, f)

            try:
                start_time = datetime.now()
                async with session.post(API_URL, json=data) as resp:
                    end_time = datetime.now()
                    exec_time_ms = (end_time - start_time).total_seconds() * 1000
                    execution_logger.info(f"{os.path.basename(file_path)} | Executed at: {end_time.strftime('%Y-%m-%d %H:%M:%S.%f')} | Time: {exec_time_ms:.2f} ms")
            except Exception:
                execution_logger.error(f"POST failed for {file_path}: {traceback.format_exc()}")

        except Exception:
            execution_logger.error(f"Failed to process {file_path}: {traceback.format_exc()}")
        finally:
            queue.task_done()

async def scheduler(queue):
    while True:
        latest_folder = get_latest_folder(BASE_FOLDER)
        if latest_folder:
            json_files = get_json_files(latest_folder)
            for f in json_files:
                scheduled_time = datetime.now()
                await queue.put((f, scheduled_time))
                schedule_logger.info(f"{os.path.basename(f)} | Scheduled at: {scheduled_time.strftime('%Y-%m-%d %H:%M:%S.%f')}")
                await asyncio.sleep(SEND_INTERVAL)
        else:
            await asyncio.sleep(0.01)
[]]
async def main():
    queue = asyncio.Queue()
    timeout = aiohttp.ClientTimeout(total=5)

    async with aiohttp.ClientSession(timeout=timeout, connector=aiohttp.TCPConnector(limit=MAX_CONCURRENT_WORKERS)) as session:
        workers = [asyncio.create_task(worker(f'worker-{i+1}', session, queue)) for i in range(MAX_CONCURRENT_WORKERS)]
        scheduler_task = asyncio.create_task(scheduler(queue))
        await asyncio.gather(scheduler_task, *workers)

if __name__ == "__main__":
    asyncio.run(main())
