import snap7
import pandas as pd
from snap7.util import get_bool, get_int, get_real, get_dint, get_byte
from snap7.types import Areas
import re
from collections import defaultdict
import time
import datetime

# --- Connect to PLC ---
def connect_to_plc(ip, rack, slot):
    client = snap7.client.Client()
    client.connect(ip, rack, slot)
    if client.get_connected():
        print(f"Connected to PLC at {ip}")
    return client

# --- Parse address string into area, db number, byte offset, bit, and tag type ---
def parse_tag(tag_type, address):
    tag_type = tag_type.strip().upper()
    address = address.strip().upper()

    if address.startswith("DB"):
        db_match = re.match(r"DB (\d+)\.DB([XBWLD]) (\d+)(?:\.(\d))?", address)
        if not db_match:
            raise ValueError(f"Invalid DB address format: {address}")
        db_number = int(db_match.group(1))
        data_type = db_match.group(2)
        byte = int(db_match.group(3))
        bit = int(db_match.group(4)) if db_match.group(4) else None
        return Areas.DB, db_number, byte, bit, tag_type

    elif address.startswith("I") or address.startswith("Q") or address.startswith("M"):
        io_match = re.match(r"([IQM]) (\d+)(?:\.(\d))?", address)
        if not io_match:
            raise ValueError(f"Invalid I/Q/M address format: {address}")
        area = {"I": Areas.PE, "Q": Areas.PA, "M": Areas.MK}[io_match.group(1)]
        byte = int(io_match.group(2))
        bit = int(io_match.group(3)) if io_match.group(3) else None
        return area, 0, byte, bit, tag_type

    elif address.startswith("MD"):
        byte = int(address.replace("MD", "").strip())
        return Areas.MK, 0, byte, None, tag_type

    else:
        raise ValueError(f"Unsupported address format: {address}")

# --- Load and group tags ---
def load_and_group_tags(csv_path):
    df = pd.read_csv(csv_path)
    if 'Type' not in df.columns or 'Address' not in df.columns:
        raise Exception("CSV must contain 'Type' and 'Address' columns")
    
    grouped = defaultdict(list)

    for _, row in df.iterrows():
        try:
            area, db, byte, bit, parsed_type = parse_tag(row['Type'], row['Address'])
            grouped[(area, db)].append((byte, bit, parsed_type, row['Address']))
        except Exception as e:
            print(f"Error parsing row: {row} - {e}")
    
    return grouped

# --- Optimized reader ---
def read_grouped_tags(client, grouped_tags):
    for (area, db), tag_list in grouped_tags.items():
        if area == Areas.DB:
            min_byte = min(byte for byte, _, _, _ in tag_list)
            max_byte = max(byte + (4 if tp in ['REAL', 'DINT'] else 2 if tp == 'INT' else 1) for byte, _, tp, _ in tag_list)
            length = max_byte - min_byte

            try:
                data = client.read_area(area, db, min_byte, length)
                for byte, bit, tag_type, address in tag_list:
                    offset = byte - min_byte
                    try:
                        if tag_type == "BOOL":
                            value = get_bool(data, offset, bit)
                        elif tag_type == "INT":
                            value = get_int(data, offset)
                        elif tag_type == "REAL":
                            value = get_real(data, offset)
                        elif tag_type == "DINT":
                            value = get_dint(data, offset)
                        elif tag_type == "BYTE":
                            value = get_byte(data, offset)
                        else:
                            value = f"Unsupported: {tag_type}"
                        print(f"{address} = {value}")
                    except Exception as pe:
                        print(f"Parse error for {address}: {pe}")
            except Exception as e:
                print(f"Failed to read DB {db}: {e}")
        else:
            # I/Q/M areas â€” read individually
            for byte, bit, tag_type, address in tag_list:
                try:
                    value = read_single_tag(client, area, db, byte, bit, tag_type)
                    print(f"{address} = {value}")
                except Exception as e:
                    print(f"Error reading {address}: {e}")

# --- Read I/Q/M tag individually ---
def read_single_tag(client, area, db, byte, bit, tag_type):
    if tag_type == "BOOL":
        data = client.read_area(area, db, byte, 1)
        return get_bool(data, 0, bit)
    elif tag_type == "INT":
        data = client.read_area(area, db, byte, 2)
        return get_int(data, 0)
    elif tag_type == "REAL":
        data = client.read_area(area, db, byte, 4)
        return get_real(data, 0)
    elif tag_type == "DINT":
        data = client.read_area(area, db, byte, 4)
        return get_dint(data, 0)
    elif tag_type == "BYTE":
        data = client.read_area(area, db, byte, 1)
        return get_byte(data, 0)
    else:
        return f"Unsupported: {tag_type}"

# --- Main ---
def main():
    ip = "172.16.12.40"
    rack = 0
    slot = 5
    csv_file = "tags.csv"

    client = connect_to_plc(ip, rack, slot)
    grouped_tags = load_and_group_tags(csv_file)

    try:
        while True:
            read_grouped_tags(client, grouped_tags)
            time.sleep(0.1)  # Read every 1 second
    except KeyboardInterrupt:
        print("Stopped by user.")
    finally:
        client.disconnect()
        print("Disconnected from PLC.")

if __name__ == "__main__":
    print(datetime.datetime.now())
    main()
    print(datetime.datetime.now())
